from sensor_library import *
from gpiozero import LED
from gpiozero import Servo
import sys
import time

servo1 = Servo(24, 2.25/1000, 0.75/1000) ## side to side
servo2 = Servo(16, 2.25/1000, 0.75/1000) ## up down
orientation_sensor = Orientation_Sensor()
led = LED(11) ##motion indicator
servo1.detach()
servo2.detach()

def reset():
    servo1.value = 0
    servo2.value = 0
    servo1.detach()
    servo2.detach()

def sensor_data():

    euler_angles = orientation_sensor.euler_angles()
    time.sleep(0.15)
    ##print("x:\t", euler_angles[0], "\ty:\t", euler_angles[1], "\tz:\t", euler_angles[2]) #prints sensor data for orientation sensor
    return euler_angles #returns orientation sensor data in form x,y,z position values

##double head nod initializes the page flipping sequence
def double_head_nod(listy): ##checks to see if double head nod was performed in the last 5 seconds
    motions = [] # 1 indicates up, -1 indicates down
    changes = []
    for i in range (1, len(listy)):
        change = listy[i]-listy[i-1]
        changes.append(change)

        if change >= 30:
            motions.append(1)
        elif change <= -30:
            motions.append(-1)
    ## checks for down up down motions (-1,1,-1)
    print("changes:  ", changes)

    print("Motions:  ", motions)
    for i in range (len(motions)-2): ##has to be -2 or because there need to be 3 values to check to not cause error
        if motions[i] == -1 and motions[i+1] == 1 and motions[i+2] == -1:
            return True
    return False
       
 

def left_or_right(listy): ##left = false right = true
    for i in range (1,len(listy)):
        old = listy[i-1]
        new = listy[i]

        #calculates the difference between initial and final angles first
        #The problem is that this is on a 0 -> 360 linear scale, we need it on -180 -> 180
        #to change this, we add 180 to the number (changes reference points on line)
        #now 0 is actually 180 (the limit we want)
        #mod 360 this number, gives us the reference point compared to 180 (the current ref point)
        #then -180 to bring it back to the old reference system
        # this tells us the distance from the initial angle
        # - indicates left, + indicates right

        change = ((new-old+180) %360)-180

        if change >=30:  ## Right Turn
            return True
        elif change <= -30: ## Left Turn
            return False
    return None
       

#To calculate the rolling average for each of the three axies                  
def rolling_avg(data):
    datalist1 = []
    datalist2 = []
    datalist3 = []
    try:
        if len(data[0]) < 15: #Finds normal average as the numbers are within the rolling average length
            avg1 = None
            avg2 = None
            avg3 = None
        elif len(data[0]) >= 15: #Finds rolling average as there are more than 5 numbers in each list now

            for i in range (len(data[0])):
                datalist1.append(data[0][i])
            avg1 = sum(datalist1)/15

            for i in range (len(data[1])):
                datalist2.append(data[1][i])
            avg2 = sum(datalist2)/15

            for i in range (len(data[2])):
                datalist3.append(data[2][i])
            avg3 = sum(datalist3)/15
    except ValueError:
        print("sensor error")

    return[avg1, avg2, avg3]
##Rolling average calculated for last 5 points of data

def led_blink(): ##blinks an led (must be used in a loop to have continuous blinking)
    led.on()
    time.sleep(0.5)
    led.off()

def reset_motors():
    servo2.max()
    servo1.mid()
    servo2.detach()
    servo1.detach()
   

def servo_routine(position): ##direction is either pos or neg to indicate flip forward or back
    ## pos is forward
    ## neg is back
   
    ## position input should be -1 for left
    ## should be positive 1 for right
    print(position)
       
    servo1.value = position
    time.sleep(0.5)
    servo1.detach()
    arbitrary = -0.5
    servo2.value = arbitrary ##position will need to be tested
    time.sleep(0.5)
    servo2.detach()
    servo1.value = -position
    time.sleep(0.5)
    servo1.detach()
    servo2.max()
    time.sleep(0.5)
    servo2.detach()
    time.sleep(0.5)
    reset()
   
   
                   
def main():

    reset()

    print ("x Orientation (Raw) \t", "y Oritenation (Raw) \t", "x Orientation (avg) \t", "y Orientation (avg) \t", "LED \t", "Servos")
   
    while True:

        data = [[],[],[]]
        while len(data[0]) < 15: #initializing ten values for sensor (last 5 seconds)
            values = sensor_data()
            data[0].append(values[0])
            data[1].append(values[1])
            data[2].append(values[2])
       
        avg = rolling_avg(data) #Finds the rolling average of the code to later be printed



        var = double_head_nod(data[1]) #Takes in the double head nod as an input
        if var == True:
            new_data = [[],[],[]]
            led.on() #The double head nod initiates the led to show that it is active

            print(data[0], "\t", data[1], "\t", avg[0], "\t", avg[1], "\t", "ON \t", "OFF" )
           
            while len(new_data[0]) < 15: #initializing ten values for sensor (last 5 seconds)
                new_values = sensor_data()
                new_data[0].append(new_values[0])
                new_data[1].append(new_values[1])
                new_data[2].append(new_values[2])
            led.off()
            print(data[0], "\t", data[1], "\t", avg[0], "\t", avg[1], "\t", "OFF \t", "OFF" )
                   


        else:
            print('no valid head turn values')
            continue
       
        direction = left_or_right(new_data[0])
        if direction == True: #Turning head left or right will flip the page forwards or backwards respectively
            try:
                print("right")
                servo_routine(-1)
                print(data[0], "\t", data[1], "\t", avg[0], "\t", avg[1], "\t", "OFF \t", "ON" )

            except KeyboardInterrupt:
                servo1.detach()
                servo2.detach()
                sys.exit(0)
            #this is where motor movement for page forward would start
        elif direction == False:
            try:
                print("left")
                servo_routine(1)
                print(data[0], "\t", data[1], "\t", avg[0], "\t", avg[1], "\t", "OFF \t", "ON" )
            except KeyboardInterrupt:
                servo1.detach()
                servo2.detach()
                sys.exit(0)
       
        continue
main()


