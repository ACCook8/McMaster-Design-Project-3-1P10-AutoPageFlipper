from sensor_library import *
from gpiozero import LED
from gpiozero import Servo
import sys
import time

servo1 = Servo(24)
servo2 = Servo(16)
orientation_sensor = Orientation_Sensor()
led = LED(11)


def sensor_data():
    euler_angles = orientation_sensor.euler_angles()
    time.sleep(0.4)
    print("x:\t", euler_angles[0], "\ty:\t", euler_angles[1], "\tz:\t", euler_angles[2]) #prints sensor data for orientation sensor
    return euler_angles #returns orientation sensor data in form x,y,z position values

##double head nod initializes the page flipping sequence
def double_head_nod(listy): ##checks to see if double head nod was performed in the last 5 seconds
    motions = [] # 1 indicates up, -1 indicates down
    changes = []
    for i in range (1, len(listy)):
        change = listy[i]-listy[i-1]
        changes.append(change)

        if change >= 30: 
            motions.append(1)
        elif change <= -30: 
            motions.append(-1)
    ## checks for down up down motions (-1,1,-1)
    print("changes:  ", changes)

    print("Motions:  ", motions)
    for i in range (len(motions)-2): ##has to be -2 or because there need to be 3 values to check to not cause error 
        if motions[i] == -1 and motions[i+1] == 1 and motions[i+2] == -1: 
            return True
    return False
        
 

def left_or_right(listy): ##left = false right = true
    for i in range (1,len(listy)): 
        old = listy[i-1]
        new = listy[i]

        #this part is fairly confusing 
        #calculates the difference between initial and final angles first
        #The problem is that this is on a 0 -> 360 linear scale, we need it on -180 -> 180
        #to change this, we add 180 to the number (changes reference points on line)
        #now 0 is actually 180 (the limit we want)
        #mod 360 this number, gives us the reference point compared to 180 (the current ref point)
        #then -180 to bring it back to the old reference system
        # this tells us the distance from the initial angle 
        # - indicates left, + indicates right

        change = ((new-old+180) %360)-180

        if change >=30:  ## Right Turn 
            return True 
        elif change <= -30: ## Left Turn
            return False
    return None
        

                    
def rolling_avg(data):
    try:
        avg1 = sum(data[0])/len(data[0])
        avg2 = sum(data[1])/len(data[1])
        avg3 = sum(data[2])/len(data[2])
    except ValueError:
        print("sensor error")

    print("Avg X:", avg1, "Avg Y:", avg2, "Avg X:", avg3)
##Rolling average calculated for last 5 seconds

def led_blink(): ##blinks an led (must be used in a loop to have continuous blinking)
    led.on()
    time.sleep(0.5)
    led.off()

                    
def main():
    
    while True:

        data = [[],[],[]] 
        while len(data[0]) < 10: ## initializing ten values for sensor (last 5 seconds)
            values = sensor_data()
            data[0].append(values[0])
            data[1].append(values[1])
            data[2].append(values[2])
        
        rolling_avg(data) ##prints out rolling average for values in the last 5 seconds of sensor data

        var = double_head_nod(data[1])
        if var == True: 
            new_data = [[],[],[]] 
            while len(new_data[0]) < 4: ## initializing ten values for sensor (last 5 seconds)
                new_values = sensor_data()
                new_data[0].append(new_values[0])
                new_data[1].append(new_values[1])
                new_data[2].append(new_values[2])
                led_blink()
                    


        else: 
            continue
        
        direction = left_or_right(new_data[0])
        if direction == True: 
            print("right")
            servo1.value(1)
            time.sleep(0.5)
            servo2.value(0.5)
            #this is where motor movement for page forward would start
        elif direction == False: 
            print ("left")
            servo1.value(-1)
            time.sleep(0.5)
            servo2.value(-0.5)
            #this is where motor movement for page back would start
